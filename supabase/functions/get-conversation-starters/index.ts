import { serve } from 'https://deno.land/std@0.177.0/http/server.ts'
import { createClient, SupabaseClient } from 'https://esm.sh/@supabase/supabase-js@2'
import { corsHeaders } from '../_shared/cors.ts' // This path should now be correct
import { Buffer } from "https://deno.land/std@0.177.0/node/buffer.ts";

// ... (rest of the Edge Function code as provided before) ...
async function sha256(message: string): Promise<string> {
  const msgUint8 = new TextEncoder().encode(message);
  const hashBuffer = await crypto.subtle.digest('SHA-256', msgUint8);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  return hashHex;
}

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    const { commonTags } = await req.json() as { commonTags: string[] }

    if (!commonTags || !Array.isArray(commonTags) || commonTags.length === 0) {
      return new Response(JSON.stringify({ error: 'Missing or invalid commonTags' }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 400,
      })
    }
    
    const GEMINI_API_KEY = Deno.env.get('GEMINI_API_KEY');
    if (!GEMINI_API_KEY) {
        console.error('[EdgeFunc] GEMINI_API_KEY is not set.');
        return new Response(JSON.stringify({ error: 'API key for generation service is not configured.' }), {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
            status: 500,
        });
    }
    const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.0-pro:generateContent?key=${GEMINI_API_KEY}`;

    const sortedTagsString = [...commonTags].sort().join(',');
    const tagsHash = await sha256(sortedTagsString);

    const supabaseAdminClient: SupabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const tagsStringForPrompt = commonTags.join(', ');
    const promptText = `Generate up to 5 short, specific, and engaging conversation starters about these shared music interests: ${tagsStringForPrompt}. Reference artists, songs, or albums. Each starter should be 1-2 sentences. Return ONLY the starters, one per line. Do not include numbering or any other explanatory text. If you cannot generate good specific starters, return "NO_STARTERS_FOUND".`;
    
    const geminiPayload = {
      contents: [{ parts: [{ text: promptText }] }],
      generationConfig: {
        temperature: 0.7,
        topK: 40,
        topP: 0.95,
        maxOutputTokens: 400,
      },
    }

    let geminiResponse;
    try {
        geminiResponse = await fetch(GEMINI_API_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(geminiPayload),
        });
    } catch (fetchError) {
        console.error('[EdgeFunc] Gemini API fetch error:', fetchError);
        return new Response(JSON.stringify({ error: `Gemini API fetch error: ${fetchError.message}` }), {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
            status: 502, 
        });
    }

    if (!geminiResponse.ok) {
      const errorBody = await geminiResponse.text();
      console.error('[EdgeFunc] Gemini API request error:', geminiResponse.status, errorBody);
      return new Response(JSON.stringify({ error: `Gemini API request failed: ${geminiResponse.status} ${errorBody}` }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 500, 
      });
    }

    const geminiResult = await geminiResponse.json();
    const fullResponseText = geminiResult?.candidates?.[0]?.content?.parts?.[0]?.text;

    if (!fullResponseText) {
      console.error('[EdgeFunc] Could not extract text from Gemini API response:', JSON.stringify(geminiResult));
      return new Response(JSON.stringify({ error: 'Could not parse Gemini API response' }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 500,
      });
    }
    
    if (fullResponseText.trim() === "NO_STARTERS_FOUND") {
        console.log('[EdgeFunc] Gemini indicated no specific starters found for tags:', commonTags);
        return new Response(JSON.stringify({ starters: [] }), { 
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
            status: 200,
        });
    }

    const starters = fullResponseText.split('\n').map(s => s.trim()).filter(s => s.length > 0 && s.length < 200);

    if (starters.length === 0) {
      console.log('[EdgeFunc] No valid starters parsed or generated by AI for tags:', commonTags);
      return new Response(JSON.stringify({ starters: [] }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200, 
      });
    }

    const { error: upsertError } = await supabaseAdminClient
      .from('generated_conversation_starters')
      .upsert({
        tags_hash: tagsHash,
        tags: commonTags,
        starters: starters,
        generated_by_model: 'gemini-1.0-pro', 
        last_accessed_at: new Date().toISOString()
      }, { onConflict: 'tags_hash' }); 

    if (upsertError) {
      console.error('[EdgeFunc] Supabase upsert error:', upsertError);
    }

    return new Response(JSON.stringify({ starters }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    })
  } catch (error) {
    console.error('[EdgeFunc] Unexpected error:', error);
    return new Response(JSON.stringify({ error: error.message || 'Internal Server Error' }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 500,
    })
  }
}) 